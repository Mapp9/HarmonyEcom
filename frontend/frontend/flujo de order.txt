Quiero implementar una funcionalidad que le muestre analiticas de los datos de venta al usuario administrador, que le permita ver las ventas por día, mes y año en un gráfico de lineas. Tambien que le permita ver los productos más vendidos en un gráfico de pastel.
Ayudame a implementar esta funcionalidad paso por paso, no pases al siguiente paso hasta que yo diga.
Este es mi código:

Backend
* > src/main/java/com/harmonydealer/ecommerce
    * > backend
        * > application
            * - OrderService.java:
                package com.harmonydealer.ecommerce.backend.application;

                import com.harmonydealer.ecommerce.backend.domain.model.Order;
                import com.harmonydealer.ecommerce.backend.domain.port.IOrderRepository;
                import lombok.AllArgsConstructor;

                @AllArgsConstructor
                public class OrderService {

                    private final IOrderRepository iOrderRepository;

                    public Order save (Order order){
                        return this.iOrderRepository.save(order);
                    }
                    public Iterable<Order> findAll(){
                        return this.iOrderRepository.findAll();
                    }
                    public Order findById(Integer id){
                        return this.iOrderRepository.findById(id);
                    }
                    public Iterable<Order> findByUserId(Integer userId){
                        return this.iOrderRepository.findByUserId(userId);
                    }
                    public void updateStateById(Integer id, String state){
                        this.iOrderRepository.updateStateById(id, state);
                    }
                }


        * > domain
            * > model
                * - Order.java:
                    package com.harmonydealer.ecommerce.backend.domain.model;

                    import lombok.Data;

                    import java.math.BigDecimal;
                    import java.time.LocalDateTime;
                    import java.util.ArrayList;
                    import java.util.List;

                    @Data
                    public class Order {

                        private Integer id;
                        private LocalDateTime dateCreated;
                        private List<OrderProduct> orderProducts;
                        private OrderState orderState;
                        private Integer userId;

                        public Order() {
                            orderProducts = new ArrayList<>();
                        }
                        public BigDecimal getTotalOrderPrice(){
                            return this.orderProducts.stream().map( orderProduct -> orderProduct.getTotalItem()).reduce(BigDecimal.ZERO, BigDecimal::add);
                        }
                    }

                * - OrderProduct.java:
                    package com.harmonydealer.ecommerce.backend.domain.model;

                    import lombok.Data;

                    import java.math.BigDecimal;

                    @Data
                    public class OrderProduct {
                        private Integer id;
                        private BigDecimal quantity;
                        private BigDecimal price;
                        private Integer productId;


                        public BigDecimal getTotalItem(){
                            return this.price.multiply(quantity);
                        }
                    }

                
            * > port
                * - IOrderRepository.java:
                    package com.harmonydealer.ecommerce.backend.domain.port;

                    import com.harmonydealer.ecommerce.backend.domain.model.Order;

                    public interface IOrderRepository {
                        Order save (Order order);
                        Order findById(Integer id);
                        Iterable<Order> findAll();
                        Iterable<Order> findByUserId(Integer userId);
                        void updateStateById(Integer id, String state);
                    }

        * > infrastructure
            * > adapter
                * - IOrderCrudRepository.java:
                    package com.harmonydealer.ecommerce.backend.infrastructure.adapter;

                    import com.harmonydealer.ecommerce.backend.domain.model.OrderState;
                    import com.harmonydealer.ecommerce.backend.infrastructure.entity.OrderEntity;
                    import com.harmonydealer.ecommerce.backend.infrastructure.entity.UserEntity;
                    import org.springframework.data.jpa.repository.Modifying;
                    import org.springframework.data.jpa.repository.Query;
                    import org.springframework.data.repository.CrudRepository;
                    import org.springframework.transaction.annotation.Transactional;

                    public interface IOrderCrudRepository extends CrudRepository<OrderEntity, Integer> {
                        @Transactional
                        @Modifying
                        @Query("UPDATE OrderEntity o SET o.orderState = :state WHERE o.id = :id")
                        void updateStateById(Integer id, OrderState state);

                        Iterable<OrderEntity> findByUserEntity(UserEntity userEntity);
                    }
                * - OrderCrudRepository.java:
                    package com.harmonydealer.ecommerce.backend.infrastructure.adapter;

                    import com.harmonydealer.ecommerce.backend.domain.model.Order;
                    import com.harmonydealer.ecommerce.backend.domain.model.OrderState;
                    import com.harmonydealer.ecommerce.backend.domain.port.IOrderRepository;
                    import com.harmonydealer.ecommerce.backend.infrastructure.entity.OrderEntity;
                    import com.harmonydealer.ecommerce.backend.infrastructure.entity.UserEntity;
                    import com.harmonydealer.ecommerce.backend.infrastructure.mapper.IOrderMapper;
                    import lombok.AllArgsConstructor;
                    import org.springframework.stereotype.Repository;

                    @Repository
                    @AllArgsConstructor
                    public class OrderCrudRepositoryImpl implements IOrderRepository {
                        private final IOrderCrudRepository iOrderCrudRepository;
                        private final IOrderMapper iOrderMapper;


                        @Override
                        public Order save(Order order) {
                            OrderEntity orderEntity = iOrderMapper.toOrderEntity(order);

                            orderEntity.getOrderProducts().forEach(
                                    orderProductEntity -> orderProductEntity.setOrderEntity(orderEntity)
                            );
                            return iOrderMapper.toOrder(iOrderCrudRepository.save(orderEntity));
                        }

                        @Override
                        public Order findById(Integer id) {
                            return iOrderMapper.toOrder(iOrderCrudRepository.findById(id).orElseThrow(
                                    () -> new RuntimeException("Orden con ID: " + id + " no encontrada.")
                            ));
                        }

                        @Override
                        public Iterable<Order> findAll() {
                            return iOrderMapper.toOrderList(iOrderCrudRepository.findAll());
                        }

                        @Override
                        public Iterable<Order> findByUserId(Integer userId) {
                            UserEntity userEntity = new UserEntity();
                            userEntity.setId(userId);
                            return iOrderMapper.toOrderList(iOrderCrudRepository.findByUserEntity(userEntity));
                        }

                        @Override
                        public void updateStateById(Integer id, String state) {
                            if (state.equals(OrderState.CANCELLED)){
                                iOrderCrudRepository.updateStateById(id, OrderState.CANCELLED);
                            }else {
                                iOrderCrudRepository.updateStateById(id, OrderState.CONFIRMED);
                            }
                        }
                    }

            * > config
                * - BeanConfiguration.java:
                    package com.harmonydealer.ecommerce.backend.infrastructure.config;

                    import com.harmonydealer.ecommerce.backend.application.*;
                    import com.harmonydealer.ecommerce.backend.domain.port.ICategoryRepository;
                    import com.harmonydealer.ecommerce.backend.domain.port.IOrderRepository;
                    import com.harmonydealer.ecommerce.backend.domain.port.IProductRepository;
                    import com.harmonydealer.ecommerce.backend.domain.port.IUserRepository;
                    import org.springframework.context.annotation.Bean;
                    import org.springframework.context.annotation.Configuration;

                    @Configuration
                    public class BeanConfiguration {

                        @Bean
                        public UserService userService(IUserRepository iUserRepository){
                            return new UserService(iUserRepository);
                        }

                        @Bean
                        public CategoryService categoryService(ICategoryRepository iCategoryRepository){
                            return new CategoryService(iCategoryRepository);
                        }

                        @Bean
                        public ProductService productService(IProductRepository iProductRepository, UploadFile uploadFile){
                            return new ProductService(iProductRepository, uploadFile);
                        }
                        @Bean
                        public OrderService orderService(IOrderRepository iOrderRepository){
                            return new OrderService(iOrderRepository);
                        }

                        @Bean
                        public UploadFile uploadFile(){
                            return new UploadFile();
                        }

                        @Bean
                        public RegistrationService registrationService(IUserRepository iUserRepository){
                            return new RegistrationService(iUserRepository);
                        }
                    }
                * - SecurityConfig.java:
                    package com.harmonydealer.ecommerce.backend.infrastructure.config;

                    import com.harmonydealer.ecommerce.backend.infrastructure.jwt.JWTAuthorizationFilter;
                    import lombok.extern.slf4j.Slf4j;
                    import org.springframework.context.annotation.Bean;
                    import org.springframework.context.annotation.Configuration;
                    import org.springframework.security.authentication.AuthenticationManager;
                    import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
                    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
                    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
                    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
                    import org.springframework.security.web.SecurityFilterChain;
                    import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
                    import org.springframework.web.cors.CorsConfiguration;

                    import java.util.Arrays;

                    @Configuration
                    @EnableWebSecurity
                    @Slf4j
                    public class SecurityConfig {

                        private final JWTAuthorizationFilter jwtAuthorizationFilter;

                        public SecurityConfig(JWTAuthorizationFilter jwtAuthorizationFilter) {
                            this.jwtAuthorizationFilter = jwtAuthorizationFilter;
                        }

                        @Bean
                        public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
                            return authenticationConfiguration.getAuthenticationManager();
                        }

                        @Bean
                        public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {
                            httpSecurity.cors(
                                    cors -> cors.configurationSource(
                                            request -> {
                                                CorsConfiguration corsConfiguration = new CorsConfiguration();
                                                corsConfiguration.setAllowedOrigins(Arrays.asList("*"));
                                                corsConfiguration.setAllowedMethods(Arrays.asList("*"));
                                                corsConfiguration.setAllowedHeaders(Arrays.asList("*"));
                                                return corsConfiguration;
                                            }
                                    ))
                                    .csrf(csrf -> csrf.disable()).authorizeHttpRequests(
                                    auth-> auth.requestMatchers("/api/v1/admin/categories/**").hasRole("ADMIN")
                                            .requestMatchers("/api/v1/admin/products/**").hasRole("ADMIN")
                                            .requestMatchers("/api/v1/orders/**").hasRole("USER")
                                            .requestMatchers("/api/v1/payments/success").permitAll()
                                            .requestMatchers("/api/v1/payments/**").hasRole("USER")
                                            .requestMatchers("/api/v1/users/**").permitAll()
                                            .requestMatchers("/images/**").permitAll()
                                            .requestMatchers("/api/v1/home/**").permitAll()
                                            .requestMatchers("/api/v1/security/**").permitAll().anyRequest().authenticated()

                            ).addFilterAfter(jwtAuthorizationFilter, UsernamePasswordAuthenticationFilter.class);

                            return httpSecurity.build();

                        }

                        @Bean
                        public BCryptPasswordEncoder passwordEncoder (){
                            return new BCryptPasswordEncoder();
                        }
                    }

            * > entity
                * - OrderEntity.java:
                    package com.harmonydealer.ecommerce.backend.infrastructure.entity;

                    import com.harmonydealer.ecommerce.backend.domain.model.OrderState;
                    import jakarta.persistence.*;
                    import lombok.Data;
                    import org.hibernate.annotations.CreationTimestamp;

                    import java.time.LocalDateTime;
                    import java.util.List;


                    @Data
                    @Entity
                    @Table(name = "orders")
                    public class OrderEntity {

                        @Id
                        @GeneratedValue(strategy = GenerationType.IDENTITY)
                        private Integer id;
                        @CreationTimestamp
                        private LocalDateTime dateCreated;
                        @Enumerated(value = EnumType.STRING)
                        private OrderState orderState;
                        @ManyToOne
                        private UserEntity userEntity;
                        @OneToMany(mappedBy = "orderEntity", cascade = CascadeType.PERSIST)
                        private List<OrderProductEntity> orderProducts;
                    }

                * - OrderProductEntity.java:
                    package com.harmonydealer.ecommerce.backend.infrastructure.entity;

                    import jakarta.persistence.*;
                    import lombok.Data;

                    import java.math.BigDecimal;

                    @Data
                    @Entity
                    @Table(name = "order_products")
                    public class OrderProductEntity {

                        @Id
                        @GeneratedValue(strategy = GenerationType.IDENTITY)
                        private Integer id;
                        private BigDecimal quantity;
                        private BigDecimal price;
                        private Integer productId;
                        @ManyToOne
                        private OrderEntity orderEntity;
                    }

            * > mapper
                * - IOrderMapper:
                    package com.harmonydealer.ecommerce.backend.infrastructure.mapper;

                    import com.harmonydealer.ecommerce.backend.domain.model.Order;
                    import com.harmonydealer.ecommerce.backend.infrastructure.entity.OrderEntity;
                    import org.mapstruct.InheritInverseConfiguration;
                    import org.mapstruct.Mapper;
                    import org.mapstruct.Mapping;
                    import org.mapstruct.Mappings;

                    @Mapper(componentModel = "spring", uses = {IOrderProductMapper.class})
                    public interface IOrderMapper {

                        @Mappings(
                                {
                                        @Mapping(source = "id", target = "id"),
                                        @Mapping(source = "dateCreated", target = "dateCreated"),
                                        @Mapping(source = "orderProducts", target = "orderProducts"),
                                        @Mapping(source = "orderState", target = "orderState"),
                                        @Mapping(source = "userEntity.id", target = "userId")
                                }
                        )
                        Order toOrder(OrderEntity orderEntity);
                        Iterable<Order> toOrderList(Iterable<OrderEntity> orderEntities);

                        @InheritInverseConfiguration
                        OrderEntity toOrderEntity(Order order);
                    }
                * - IOrderProductMapper.java:
                    package com.harmonydealer.ecommerce.backend.infrastructure.mapper;

                    import com.harmonydealer.ecommerce.backend.domain.model.OrderProduct;
                    import com.harmonydealer.ecommerce.backend.infrastructure.entity.OrderProductEntity;
                    import org.mapstruct.InheritInverseConfiguration;
                    import org.mapstruct.Mapper;
                    import org.mapstruct.Mapping;
                    import org.mapstruct.Mappings;

                    @Mapper(componentModel = "spring")
                    public interface IOrderProductMapper {
                        @Mappings(
                                {
                                        @Mapping(source = "id", target = "id"),
                                        @Mapping(source = "quantity", target = "quantity"),
                                        @Mapping(source = "price", target = "price"),
                                        @Mapping(source = "productId", target = "productId")
                                }
                        )
                        OrderProduct toOrderProduct(OrderProductEntity orderProductEntity);
                        Iterable<OrderProduct> toOrderProductList(Iterable<OrderProductEntity> orderProductEntities);

                        @InheritInverseConfiguration
                        OrderProductEntity toOrderProductEntity(OrderProduct orderProduct);
                    }

            * > rest
                * - OrderController.java:
                    package com.harmonydealer.ecommerce.backend.infrastructure.rest;


                    import com.harmonydealer.ecommerce.backend.application.OrderService;
                    import com.harmonydealer.ecommerce.backend.domain.model.Order;
                    import com.harmonydealer.ecommerce.backend.domain.model.OrderState;
                    import lombok.AllArgsConstructor;
                    import lombok.extern.slf4j.Slf4j;
                    import org.springframework.http.ResponseEntity;
                    import org.springframework.web.bind.annotation.*;

                    @RestController
                    @RequestMapping("/api/v1/admin/orders")
                    @Slf4j
                    @AllArgsConstructor
                    @CrossOrigin(origins = "http://localhost:4200")
                    public class AdminOrderController {
                        private final OrderService orderService;

                        @PostMapping
                        public ResponseEntity<Order> save(@RequestBody Order order){
                            if (order.getOrderState().toString().equals(OrderState.CANCELLED.toString())){
                                order.setOrderState(OrderState.CANCELLED);
                            }else {
                                order.setOrderState(OrderState.CONFIRMED);
                            }

                            return ResponseEntity.ok(orderService.save(order));
                        }

                        @GetMapping
                        public ResponseEntity<Iterable<Order>> findAll(){
                            return ResponseEntity.ok(orderService.findAll());
                        }

                        @GetMapping("/{variable}")
                        public ResponseEntity<Order> findById(@PathVariable("variable") Integer id){
                            return ResponseEntity.ok(orderService.findById(id));
                        }

                        @GetMapping("/by-user/{id}")
                        public ResponseEntity<Iterable<Order>> findByUserId(@PathVariable("id") Integer userId){
                            return ResponseEntity.ok(orderService.findByUserId(userId));
                        }
                    }

Frontend
* > src
    * > app
        * > common
            * - order-product.ts:
                export class OrderProduct {
                    constructor(
                        public id:number|null,
                        public productId:number,
                        public quantity:number,
                        public price:number
                    
                    ) {

                    }
                }

            * - order-state.ts:
                export class OrderProduct {
                    constructor(
                        public id:number|null,
                        public productId:number,
                        public quantity:number,
                        public price:number
                    
                    ) {

                    }
                }

            * - order.ts:
                import { OrderProduct } from "./order-product";
                import { OrderState } from "./order-state";

                export class Order {

                    constructor(
                        public id:number|null,
                        public dateCreated:Date,
                        public orderProducts:OrderProduct [],
                        public userId:number,
                        public orderState:OrderState
                    
                    ) {}

                    getTotal(){
                        let total = 0;
                        for(let orderProduct of this.orderProducts){
                            total += orderProduct.price * orderProduct.quantity;
                            console.log('Total: '+ total);
                        }
                    }
                }

        * > components
            * > orders
                * > order-history (Este es el componente que quiero desarrollar para visualizar las ordenes)
                    * - order-history.component.css 
                    * - order-history.component.html
                    * - order-history.component.ts
        * > service
            * - order.service.ts:
                import { HttpClient } from '@angular/common/http';
                import { Injectable } from '@angular/core';
                import { Order } from '../common/order';
                import { Observable } from 'rxjs';
                import { HeaderService } from './header.service';

                @Injectable({
                providedIn: 'root'
                })
                export class OrderService {
                private apiUrl : string = "http://localhost:8085/api/v1/orders";
                private update : string = 'update/state/order';
                constructor(private httpClient:HttpClient, private headerService : HeaderService) { }

                createOrder(order:Order):Observable<Order>{
                    return this.httpClient.post<Order>(this.apiUrl, order, {headers:this.headerService.headers});
                }

                updateOrder(formData:any):Observable<any>{
                    return this.httpClient.post(`${this.apiUrl}/${this.update}`, formData, {headers:this.headerService.headers});
                }

                getOrderByUser(userId:number):Observable<Order[]>{
                    return this.httpClient.get<Order[]>(`${this.apiUrl}/by-user/${userId}`, {headers:this.headerService.headers});
                }

                getOrderById(orderId:number):Observable<Order>{
                    return this.httpClient.get<Order>(`${this.apiUrl}/${orderId}`, {headers:this.headerService.headers})
                }
                }


"gon.m@test.com"
"Test.1234"

Este es mi código:

admin-analytics.component:
html: 
<div class="container">
    <h2>Ventas por Día, Mes y Año</h2>
    <canvas id="salesChart"></canvas>
  
    <h2>Productos Más Vendidos</h2>
    <canvas id="topProductsChart"></canvas>
  </div>
ts:
import { Component, OnInit } from '@angular/core';
import { Chart } from 'chart.js';
import { AnalitycsService } from 'src/app/services/analitycs.service';

@Component({
  selector: 'app-admin-analytics',
  templateUrl: './admin-analytics.component.html',
  styleUrls: ['./admin-analytics.component.css']
})
export class AdminAnalyticsComponent implements OnInit {

  constructor(private analitycsService: AnalitycsService ) {}
  ngOnInit(): void {
    
  }

  loadSalesData() {
    this.analitycsService.getSalesByDay().subscribe((data: any[]) => {
      const labels = data.map(sale => sale[0]);
      const salesData = data.map(sale => sale[1]);

      new Chart("salesChart", {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Ventas por Día',
            data: salesData,
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 1,
            fill: false
          }]
        },
        options: {
          responsive: true,
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    });
  }

  loadTopProductsData() {
    this.analitycsService.getTopSellingProducts().subscribe((data: any[]) => {
      const labels = data.map(product => `Producto ${product[0]}`);
      const quantities = data.map(product => product[1]);

      new Chart("topProductsChart", {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            label: 'Productos más vendidos',
            data: quantities,
            backgroundColor: [
              'rgba(255, 99, 132, 0.2)',
              'rgba(54, 162, 235, 0.2)',
              'rgba(255, 206, 86, 0.2)',
              'rgba(75, 192, 192, 0.2)',
              'rgba(153, 102, 255, 0.2)',
              'rgba(255, 159, 64, 0.2)'
            ],
            borderColor: [
              'rgba(255, 99, 132, 1)',
              'rgba(54, 162, 235, 1)',
              'rgba(255, 206, 86, 1)',
              'rgba(75, 192, 192, 1)',
              'rgba(153, 102, 255, 1)',
              'rgba(255, 159, 64, 1)'
            ],
            borderWidth: 1
          }]
        },
        options: {
          responsive: true
        }
      }

      )
    }

    )
  }

}
analitycsService(orderService lo estoy utilizando para otra función):
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/internal/Observable';
import { HeaderService } from './header.service';

@Injectable({
  providedIn: 'root'
})
export class AnalitycsService {

  private apiUrl : string = "http://localhost:8085/api/v1/admin/analytics";
  constructor(private httpClient: HttpClient, private headerService : HeaderService) { }

  getSalesByDay(): Observable<any[]> {
    return this.httpClient.get<any[]>(`${this.apiUrl}/sales/day`, {headers:this.headerService.headers});
  }

  getSalesByMonth(): Observable<any[]> {
    return this.httpClient.get<any[]>(`${this.apiUrl}/sales/month`, {headers:this.headerService.headers});
  }

  getSalesByYear(): Observable<any[]> {
    return this.httpClient.get<any[]>(`${this.apiUrl}/sales/year`, {headers:this.headerService.headers});
  }

  getTopSellingProducts(): Observable<any[]> {
    return this.httpClient.get<any[]>(`${this.apiUrl}/top-products`, {headers:this.headerService.headers});
  }
}
